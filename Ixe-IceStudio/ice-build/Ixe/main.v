// Code generated by Icestudio 0.10

`default_nettype none

//---- Top entity
module main (
 input v4f58e8,
 input v2097e9,
 input vclk,
 output ve38af7,
 output v34c7a9,
 output ve9309f
);
 wire w0;
 wire w1;
 wire [0:7] w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 assign ve9309f = w0;
 assign w1 = v4f58e8;
 assign ve38af7 = w4;
 assign w7 = v2097e9;
 assign v34c7a9 = w9;
 assign w11 = vclk;
 assign w12 = vclk;
 assign w13 = vclk;
 assign w14 = vclk;
 assign w15 = vclk;
 assign w9 = w4;
 assign w12 = w11;
 assign w13 = w11;
 assign w13 = w12;
 assign w14 = w11;
 assign w14 = w12;
 assign w14 = w13;
 assign w15 = w11;
 assign w15 = w12;
 assign w15 = w13;
 assign w15 = w14;
 vc6459c v26df32 (
  .v8caaa5(w0),
  .v19b8dd(w5),
  .v05e99b(w6),
  .ve9a78f(w11)
 );
 vb9ce14 v2c1f6c (
  .v6a1cbe(w1),
  .v2d03ef(w2),
  .v6a2ebd(w3),
  .v7114a9(w12)
 );
 main_va93bf2 va93bf2 (
  .data(w2),
  .check(w3),
  .exec(w4),
  .clk(w13)
 );
 main_vdb5a39 vdb5a39 (
  .data(w5),
  .txmit(w6),
  .button(w10),
  .clk(w14)
 );
 v8026ab vfcf217 (
  .vedbc89(w7),
  .v758f58(w8)
 );
 vcfd9ba v37c8ae (
  .v6a82dd(w8),
  .vd4e5d7(w10),
  .v444878(w15)
 );
endmodule

//---- Top entity
module vc6459c #(
 parameter ved2ada = 9600
) (
 input ve9a78f,
 input [7:0] v19b8dd,
 input v05e99b,
 output v8caaa5,
 output v2da441,
 output v01321e
);
 localparam p1 = ved2ada;
 wire w0;
 wire w2;
 wire [0:7] w3;
 wire w4;
 wire w5;
 wire w6;
 assign v8caaa5 = w0;
 assign w2 = ve9a78f;
 assign w3 = v19b8dd;
 assign w4 = v05e99b;
 assign v2da441 = w5;
 assign v01321e = w6;
 vc6459c_vedebcc #(
  .BAUD(p1)
 ) vedebcc (
  .TX(w0),
  .clk(w2),
  .data(w3),
  .txmit(w4),
  .busy(w5),
  .done(w6)
 );
endmodule

//---------------------------------------------------
//-- Serial-tx
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Transmisor serie
//---------------------------------------------------

module vc6459c_vedebcc #(
 parameter BAUD = 0
) (
 input clk,
 input [7:0] data,
 input txmit,
 output TX,
 output busy,
 output done
);
 //-- Constantes para obtener las velocidades estándares
 `define B115200 139 
 `define B57600  208
 `define B38400  313
 `define B19200  833
 `define B9600   1667
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 //-- Constante para calcular los baudios
 localparam BAUDRATE = (BAUD==115200) ? `B115200 : //-- OK
                       (BAUD==57600)  ? `B57600  : //-- OK
                       (BAUD==38400)  ? `B38400  : //-- Ok
                       (BAUD==19200)  ? `B19200  : //-- OK
                       (BAUD==9600)   ? `B9600   : //-- OK
                       (BAUD==4800)   ? `B4800   : //-- OK 
                       (BAUD==2400)   ? `B2400   : //-- OK
                       (BAUD==1200)   ? `B1200   : //-- OK
                       (BAUD==600)    ? `B600    : //-- OK
                       (BAUD==300)    ? `B300    : //-- OK
                       `B115200 ;  //-- Por defecto 115200 baudios
 
 
 //---- GENERADOR DE BAUDIOS
 
 //-- Calcular el numero dde bits para almacenar el divisor
 localparam N = $clog2(BAUDRATE);
 
 //-- Contador para implementar el divisor
 //-- Es un contador modulo BAUDRATE
 reg [N-1:0] divcounter = 0;
 
 //-- Cable de reset para el contador
 //-- Comparador que resetea el contador cuando se alcanza el tope
 //-- o cuando el estado del biestable es 0 (apagado)
 wire reset = ov_gen | (state == 0);
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Hemos llegado al final
 wire ov_gen = (divcounter == BAUDRATE-1);
 
 
 
 //-- REGISTRO DESPLAZAMIENTO
 
 //-- Salida serie. Inicialmete a 1 (reposo) 
 reg TX = 1;
 
 //-- Registro de desplazamiento de 9 bits
 //-- Inicializado todo a 1s
 reg [8:0] q = 9'h1FF;
 
 //-- La entrada de shift es la salida del generador de baudios
 wire shift = ov_gen;
 
 always @(posedge clk)
   if (txmit_tic)
   //-- Carga del registro
     q <= {data, 1'b0};
     
   else if (shift)
     //-- Desplazamiento. Rellenar con 1 (bit de stop)
     q <= {1'b1, q[8:1]};
     
 //-- Sacar el bit de menor peso por serial-out    
 wire so;
 assign so = q[0];
 
 //-- La salida tx la registramos
 always @(posedge clk)
   TX <= so;
   
 //-- La señal de entrada txmit se pasa por un 
 //-- detector de flancos de subida para generar un tic
 reg q_re = 0;
 wire txmit_tic;
 
 always @(posedge clk)
   q_re <= txmit;
   
 assign txmit_tic = (~q_re & txmit);  
 
 
 
 //-- Estado de transmisor
 //-- 0: Parado
 //-- 1: Ocupado (transmitiendo)
 reg state = 0;
   
 always @(posedge clk)
   //-- Empieza la transmision: ocupado
   if (txmit)
     state <= 1'b1;
     
   //-- Acaba la transmision: libre    
   else if (ov)
     state <= 1'b0;
 
 //-- Contador de bits enviados
 reg [3:0] bits = 0;
 always @(posedge clk)
   //-- Si la cuenta ha terminado... volver a 0
   if (ov)
     bits <= 2'b00;
   else
     if (shift)
       bits <= bits + 1;
 
 //-- Comprobar si se ha transmitido el último bit (overflow)
 //-- 1 bit de start + 8 bits de datos + 1 bit de stop
 wire ov = (bits == 10);
 
 //-- La señal de ocupado es el estado del transmisor
 assign busy = state;
 
 //-- La señal de done es la de overflow pero retrasada un
 //-- periodo de reloj del sistema y que el biestable 
 //-- llegue al estado de parado antes de que se 
 //-- empiece otra transmision
 
 reg done=0;
 
 always @(posedge clk)
   done <= ov;
 
endmodule
//---- Top entity
module vb9ce14 #(
 parameter v47d474 = 9600
) (
 input v7114a9,
 input v6a1cbe,
 output [7:0] v2d03ef,
 output ve77bd8,
 output v6a2ebd
);
 localparam p4 = v47d474;
 wire w0;
 wire w1;
 wire [0:7] w2;
 wire w3;
 wire w5;
 assign w0 = v7114a9;
 assign w1 = v6a1cbe;
 assign v2d03ef = w2;
 assign v6a2ebd = w3;
 assign ve77bd8 = w5;
 vb9ce14_vf55761 #(
  .BAUD(p4)
 ) vf55761 (
  .clk(w0),
  .RX(w1),
  .data(w2),
  .rcv(w3),
  .busy(w5)
 );
endmodule

//---------------------------------------------------
//-- Serial-rx
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Receptor serie asíncrono. Velocidad por defecto: 115200 baudios
//---------------------------------------------------

module vb9ce14_vf55761 #(
 parameter BAUD = 0
) (
 input clk,
 input RX,
 output [7:0] data,
 output busy,
 output rcv
);
 //-- Constantes para obtener las velocidades estándares
 `define B115200 104 
 `define B57600  208
 `define B38400  313
 `define B19200  833
 `define B9600   1667
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 //-- Constante para calcular los baudios
 localparam BAUDRATE = (BAUD==115200) ? `B115200 : //-- OK
                       (BAUD==57600)  ? `B57600  : //-- OK
                       (BAUD==38400)  ? `B38400  : //-- Ok
                       (BAUD==19200)  ? `B19200  : //-- OK
                       (BAUD==9600)   ? `B9600   : //-- OK
                       (BAUD==4800)   ? `B4800   : //-- OK 
                       (BAUD==2400)   ? `B2400   : //-- OK
                       (BAUD==1200)   ? `B1200   : //-- OK
                       (BAUD==600)    ? `B600    : //-- OK
                       (BAUD==300)    ? `B300    : //-- OK
                       `B115200 ;  //-- Por defecto 115200 baudios
 
 
 
 
 //-- Calcular el numero de bits para almacenar el divisor
 localparam N = $clog2(BAUDRATE);
 
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d1;
 reg din;
 
 always @(posedge clk)
  d1 <= RX;
  
 //-- Din contiene el dato serie de entrada listo para usarse   
 always @(posedge clk)
   din <= d1;
   
 //------ Detectar el bit de start: flanco de bajada en din
 
 //-- Registro temporal
 reg q_t0 = 0;
 
 always @(posedge clk)
   q_t0 <= din;
   
 //-- El cable din_fe es un "tic" que aparece cuando llega el flanco de 
 //-- bajada
 wire din_fe = (q_t0 & ~din);
 
 //-------- ESTADO DEL RECEPTOR
 
 //-- 0: Apagado. Esperando
 //-- 1: Encendido. Activo. Recibiendo dato
 reg state = 0;
 
 always @(posedge clk)
   //-- Se pasa al estado activo al detectar el flanco de bajada
   //-- del bit de start
   if (din_fe)
     state <= 1'b1;
     
   //-- Se pasa al estado inactivo al detectar la señal rst_state    
   else if (rst_state)
     state<=1'b0;
 
 //------------------ GENERADOR DE BAUDIOS -----------------------------
 //-- Se activa cuando el receptor está encendido
 
 
 //-- Calcular la mitad del divisor BAUDRATE/2
 localparam BAUD2 = (BAUDRATE >> 1);
 
 //-- Contador del sistema, para esperar un tiempo de  
 //-- medio bit (BAUD2)
 
 //-- NOTA: podria tener N-2 bits en principio
 reg [N-1: 0] div2counter = 0;
 
 //-- Se genera primero un retraso de BAUD/2
 //-- El proceso comienza cuando el estado pasa a 1
 
 always @(posedge clk)
 
   //-- Contar
   if (state) begin
     //-- Solo cuenta hasta BAUD2, luego  
     //-- se queda en ese valor hasta que
     //-- ena se desactiva
     if (div2counter < BAUD2) 
       div2counter <= div2counter + 1;
   end else
     div2counter <= 0;
 
 //-- Habilitar el generador de baudios principal
 //-- cuando termine este primer contador
 wire ena2 = (div2counter == BAUD2);
 
 
 //------ GENERADOR DE BAUDIOS PRINCIPAL
 
 //-- Contador para implementar el divisor
 //-- Es un contador modulo BAUDRATE
 reg [N-1:0] divcounter = 0;
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Esta señal contiene el tic
 wire ov = (divcounter == BAUDRATE-1);
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = ov | (ena2 == 0);
 
 //-- El cable con el tic para capturar cada bit lo llamamos
 //-- bit_tic, y es la señal de overflow del contador
 wire bit_tic = ov;
 
 //-------- REGISTRO DE DESPLAZAMIENTO -----------
 //-- Es el componente que pasa los bits recibidos a paralelo
 //-- La señal de desplazamiento usada es bit_tic, pero sólo cuando  
 //-- estamos en estado de encendido (state==1)
 //-- Es un registro de 9 bits: 8 bits de datos + bit de stop
 //-- El bit de start no se almacena, es el que ha servido para
 //-- arrancar el receptor
 
 reg [8:0] sr = 0;
 
 always @(posedge clk)
   //-- Se captura el bit cuando llega y el receptor
   //-- esta activado
   if (bit_tic & state)
     sr <= {din, sr[8:1]};
     
 //-- El dato recibido se encuentran en los 8 bits menos significativos
 //-- una vez recibidos los 9 bits
 
 //-------- CONTADOR de bits recibidos
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [4:0] cont = 0;
 
 always @(posedge clk)
 
   //-- El contador se pone a 0 si hay un overflow o 
   //-- el receptor está apagado 
   if ((state==0)| ov2)
     cont <= 0;
   else
     //-- Receptor activado: Si llega un bit se incrementa
     if (bit_tic)
       cont <= cont + 1;
       
 //-- Comprobar overflow
 wire ov2 = (cont == 9);
     
 //-- Esta señal de overflow indica el final de la recepción
 wire fin = ov2;
 
 //-- Se conecta al reset el biestable de estado
 wire rst_state = fin;
 
 //----- REGISTRO DE DATOS -------------------
 //-- Registro de 8 bits que almacena el dato final
 
 //-- Bus de salida con el dato recibido
 reg data = 0;
 
 always @(posedge clk)
 
   //-- Si se ha recibido el ultimo bit, capturamos el dato
   //-- que se encuentra en los 8 bits de menor peso del
   //-- registro de desplazamiento
   if (fin)
     data <= sr[7:0];
 
 //-- Comunicar que se ha recibido un dato
 //-- Tic de dato recibido
 reg rcv = 0;
 always @(posedge clk)
   rcv <= fin;
 
 //-- La señal de busy es directamente el estado del receptor
 assign busy = state;
 
 
endmodule
//---- Top entity
module v8026ab (
 input vedbc89,
 output v758f58
);
 wire w0;
 wire w1;
 assign w0 = vedbc89;
 assign v758f58 = w1;
 v8026ab_v34955f v34955f (
  .i(w0),
  .o(w1)
 );
endmodule

//---------------------------------------------------
//-- Pull-up
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- FPGA internal pull-up configuration on the connected input port
//---------------------------------------------------

module v8026ab_v34955f (
 input i,
 output o
);
 // Pull up
 
 wire din, dout, outen;
 
 assign o = din;
 
 SB_IO #(
     .PIN_TYPE(6'b 1010_01),
     .PULLUP(1'b 1)
 ) io_pin (
     .PACKAGE_PIN(i),
     .OUTPUT_ENABLE(outen),
     .D_OUT_0(dout),
     .D_IN_0(din)
 );
endmodule
//---- Top entity
module vcfd9ba (
 input v444878,
 input v6a82dd,
 output vd4e5d7
);
 wire w0;
 wire w1;
 wire w2;
 assign vd4e5d7 = w0;
 assign w1 = v444878;
 assign w2 = v6a82dd;
 vcfd9ba_va7041c va7041c (
  .out(w0),
  .clk(w1),
  .in(w2)
 );
endmodule

//---------------------------------------------------
//-- Debouncer
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Remove the rebound on a mechanical switch
//---------------------------------------------------

module vcfd9ba_va7041c (
 input clk,
 input in,
 output out
);
 //-- Debouncer Circuit
 //-- It produces a stable output when the
 //-- input signal is bouncing
 
 reg btn_prev = 0;
 reg btn_out_r = 0;
 
 reg [16:0] counter = 0;
 
 
 always @(posedge clk) begin
 
   //-- If btn_prev and btn_in are differents
   if (btn_prev ^ in == 1'b1) begin
     
       //-- Reset the counter
       counter <= 0;
       
       //-- Capture the button status
       btn_prev <= in;
   end
     
   //-- If no timeout, increase the counter
   else if (counter[16] == 1'b0)
       counter <= counter + 1;
       
   else
     //-- Set the output to the stable value
     btn_out_r <= btn_prev;
 
 end
 
 assign out = btn_out_r;
 
endmodule

module main_va93bf2 (
 input clk,
 input [7:0] data,
 input check,
 output exec
);
 
 
   
   always @(posedge clk) begin
     if (data == 8'h4C) begin
       exec = 1;  // trigger output if values match
     end else begin
       exec = 0;  // reset output if values don't match
     end
   end
 
endmodule

module main_vdb5a39 (
 input clk,
 input button,
 output [7:0] data,
 output txmit
);
  reg [7:0] register_value;
 
   always @(posedge clk) begin
     if (button) begin
       register_value <= 8'h62;
       txmit=1;
     end else begin
       txmit=0;
     end
   end
   
   assign data = register_value;
endmodule
